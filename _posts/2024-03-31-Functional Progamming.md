---
title: Functional Programming (using Ocaml)
date: 2024-03-31 18:22:12 +0000
categories: #[TOP_CATEGORY, SUB_CATEGORY]
tags: [programming] # TAG names should always be lowercase
---

## Desire to Code

I wouldn't claim to have taken a formal programming course and yet I feel confident in being able to come up with programmatic solutions to problems when necessary.
This has always felt hacky, and without much direction, I haven't felt that I could escape this feeling.
I've considered two ways to address this desire to improve my programming skills.

1. Learn and practice algorithms -- Unknowns remain here.
2. Branch into a different way of thinking with programming -- Functional programming instead of OOP.

To learn and practise algorithms I need to pick a language.
I'm familiar with Python and C, although neither seems like a good choice.
Python is syntactically easy but I've never considered it useful beyond scripting.
The worry with C is that I'll be fighting the syntax just as much as the algorithm implementation.
Rust carries the same concerns as C, but at least I might get better help with errors.

The second task is finding the list of algorithms to implement.
There are plenty of resources, I just need to pick one.
Pairing this with Advent of Code problems will surely help keep everything refreshed in my mind.

## Functional Programming

Although I've not had formal OOP training, it's still the most utilised way to code (at least on the surface of the internet).
So whatever I might have learned through the years would have been through an OOP lens.
As a change of pace, I wanted to explore functional programming to see what I could learn from the experience.

There are great resources for that online for free as well.

* [OCaml from the very beginning](https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf)
* [OCaml Programming: Correct + Efficient + Beautiful](https://cs3110.github.io/textbook/cover.html)

Peculiar titles aside, working through the first book and exercises has been interesting, as I can see the complexity that comes from adopting a recursive thinking style.

Once I've finished the first book I will look at the second one, which is much more interactive.
It will either be as useful or it will supplement knowledge, so it's more likely that I will skim through it.

Halfway through the first book, I began to keep track of the exercises and questions, and they now live on a [GitHub repo](https://github.com/Emc54/ocaml_workspace) of mine for posterity.
I did look back on the first 5 chapters, and most of the interesting exercises ended up in the `utils.ml` file, so I haven't bothered repeating them.
